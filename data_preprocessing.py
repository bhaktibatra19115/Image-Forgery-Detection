# -*- coding: utf-8 -*-
"""data_preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g31XOEdf69_REJ-uabmJIC3cvER-jL-d

# LIBRARIES
"""

import pandas as pd
import cv2
import matplotlib.pyplot as plt
from tqdm import tqdm
import pickle
import numpy as np
import tensorflow as tf
from skimage.util.shape import view_as_windows
from google.colab.patches import cv2_imshow
from skimage.measure import compare_ssim
import random
from skimage import io

"""# DATA READ"""

gt_train=pd.read_csv('groundtruth_train_new.csv')
# gt_test=pd.read_csv('gt_test.csv')

gt_train.head(10)

len(gt_train)

"""AUTHENTIC DATA"""

train_au =pd.read_csv('auth_train_new.csv')
test_au=pd.read_csv('authentic_test_new.csv')

"""TAMPERED DATA"""

train_tp=pd.read_csv('tampered_train_new.csv')
test_tp=pd.read_csv('tampered_test_new.csv')

au=cv2.imread(train_mask_df['authentic_path'].iloc[5])
tp=cv2.imread(train_mask_df['tampered_path'].iloc[5])
mask=train_mask_df['mask'].iloc[5]
gt=cv2.imread(gt_train['0'].iloc[5])

cv2_imshow(au)
cv2_imshow(tp)
cv2_imshow(mask)
cv2_imshow(gt)

train_tp.head(10)

len(train_tp)

cv2_imshow(np.hstack([cv2.imread(train_tp['0'].iloc[0]), cv2.imread(train_au['0'].iloc[0])  ]))

"""# data_creation using ground truth

Authentic_patches
"""

def authentic_patch(df):

  l1=[]
  stride =8
  window_shape = (128, 128, 3)
  for i in tqdm(range(len(df))):
    au=cv2.imread(df['0'].iloc[i])
    windows = view_as_windows(au, window_shape, step=stride)
    non_tampered_patches = []
    for m in range(windows.shape[0]):
        for n in range(windows.shape[1]):
            non_tampered_patches += [windows[m][n][0]]

    # for /l in tqdm(range(len(non_tampered_patches))):
    k=2
    j=False
    if len(non_tampered_patches)<4:
      j=True

    indexes = np.random.choice(len(non_tampered_patches), k, replace=j)
    print(len(indexes))
    for ind in enumerate(indexes):
      # print(len(indexes))
      # print(ind[0],ind,ind[1])
      img=non_tampered_patches[ind[1]]
      if ind[1]%2==0:
        img1=cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
      else:
        img1=cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)


      io.imsave('/content/drive/My Drive/SML _ PROJECT/authentic_patches/' + str(i) + '_' + str(ind[0]) + '_' + '1_.png', np.asarray(img) )
      io.imsave('/content/drive/My Drive/SML _ PROJECT/authentic_patches/' + str(i) + '_' + str(ind[0]) + '_'+'r'+'_'+'1_.png', np.asarray(img1) )

authentic_patch(train_au)

"""tampered patches"""

def patch_cal(df , gt):
  tampered=[]
  masks=[]
  stride =8
  window_shape = (128, 128, 3)
  for i in tqdm(range(2650, (len(df)))):
    mask=cv2.imread(gt['0'].iloc[i])   #read images
    tp=cv2.imread(df['0'].iloc[i])
    if mask.shape[2] == 4 or mask.shape[2]==1 or mask.shape[2]==2:
        mask = cv2.cvtColor(mask, cv2.COLOR_BGRA2BGR)
    tp,mask=shape_checker(tp,mask)
    if mask.shape[0]==tp.shape[0] and mask.shape[1]==tp.shape[1]:
      tp_patches = view_as_windows(tp, window_shape, step=stride)
      mask_patches=view_as_windows(mask, window_shape, step=stride)
      tampered_patches = []
      masked_patches=[]
        # find tampered patches
      for m in range(mask_patches.shape[0]):
          for n in range(mask_patches.shape[1]):
              im = tp_patches[m][n][0]
              ma = mask_patches[m][n][0]
              num_zeros = (ma == 0).sum()
              num_ones = (ma == 255).sum()
              total = num_ones + num_zeros
          
              if num_zeros <= 0.90 * total:
                  tampered_patches += [im]
                  masked_patches += [ma]

              if len(tampered_patches)==0:
                if num_zeros <= 1* total:
                  tampered_patches += [im]
                  masked_patches += [ma]
      # for l in tqdm(range(len(tampered_patches))):
      k=2
      j=False
      if len(tampered_patches)<4:
        j=True

      indexes = np.random.choice(len(tampered_patches), k, replace=j)

      for ind in enumerate(indexes):
        img=tampered_patches[ind[1]]
        if ind[1]%2==0:
          img1=cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
        else:
          img1=cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)


        io.imsave('/content/drive/My Drive/SML _ PROJECT/tampered_patches/' + str(i) + '_' + str(ind[0]) + '_' + '0_.png', np.asarray(img) )
        io.imsave('/content/drive/My Drive/SML _ PROJECT/tampered_patches/' + str(i) + '_' + str(ind[0]+1) + '_'+'r'+'_' + '0_.png', np.asarray(img1) )
    else:print(i)

patch_cal(train_tp,gt_train)

"""# data creation without using ground truth

MASK GENERATOR
"""

def shape_checker(image1,image2):
   
    if image1.shape == image2.shape:
        return image1, image2
    elif image1.shape[0] == image2.shape[1] and image1.shape[1] == image2.shape[0]:
        image2 = np.reshape(image2, (image1.shape[0], image1.shape[1], image2.shape[2]))
        return image1, image2
    else:
        return image1, image2

"""tampered mask creator"""

def mask_creator(dataframe1 , dataframe2):   #authentic #tampered
  mask=[]
  au_path=[]
  tp_path=[]
  
  for i in tqdm(range(len(dataframe2))):
    au=cv2.imread(dataframe1['0'].iloc[i])
    tp=cv2.imread(dataframe2['0'].iloc[i])
    au , tp =check_and_reshape(au,tp)
    if tp.shape == au.shape:
      # convert images to grayscale
      gray_au_image = cv2.cvtColor(au, cv2.COLOR_BGR2GRAY)
      gray_sp_image = cv2.cvtColor(tp, cv2.COLOR_BGR2GRAY)
      # get the difference of the 2 grayscale images
      diff=gray_au_image-gray_sp_image
      diff = cv2.medianBlur(diff, 1)
      # make background black and tampered area white
      msk = np.ones_like(diff)
      msk[diff < 0.98] = 1
      msk[diff >= 0.98] = 0
      msk = (msk * 255).astype("uint8")
      mask.append(msk)
      au_path.append(dataframe1['0'].iloc[i])
      tp_path.append(dataframe2['0'].iloc[i])
    
      
  return mask , au_path , tp_path

"""tampered test and train list"""

# mask_train, au_train_path , tp_train_path ,ijn=mask_creator(train_au,train_tp)

# mask_test, au_test_path , tp_test_path ,ijnt=mask_creator(test_au,test_tp)

"""DATA FRAME"""

# train_data_frame=pd.DataFrame({'authentic_path':au_train_path , 'tampered_path':tp_train_path , 'mask':mask_train})

# test_data_frame=pd.DataFrame({'authentic_path':au_test_path , 'tampered_path':tp_test_path , 'mask':mask_test})

"""Load file :mask_patch_train/test_tp.sav**"""

train_mask_df=pickle.load(open('mask_patch_train_tp.sav','rb'))
# test_mask_df=pickle.load(open('mask_patch_test_tp.sav','rb'))

# train_mask_df.head(5)

# test_mask_df.head(5)

"""TAMPERED PATCH - using mask"""

def patch_cal(train_data_frame):
  tampered=[]
  masks=[]
  stride =8
  window_shape = (128, 128, 3)
  for i in tqdm(range (len(train_data_frame))):
    t=cv2.imread(train_data_frame['tampered_path'].iloc[i])
    m=train_data_frame['mask'].iloc[i]
    m = cv2.cvtColor(m, cv2.COLOR_GRAY2BGR)
    t , m =check_and_reshape(t,m)

    tp_patches = view_as_windows(t, window_shape, step=stride)
    mask_patches=view_as_windows(m, window_shape, step=stride)

    tampered_patches = []
    masked_patches=[]
      # find tampered patches
    for m in range(tp_patches.shape[0]):
        for n in range(tp_patches.shape[1]):
            im = tp_patches[m][n][0]
            ma = mask_patches[m][n][0]
            num_zeros = (ma == 0).sum()
            num_ones = (ma == 255).sum()
            total = num_ones + num_zeros
        
            if num_zeros <= 0.90 * total:
                tampered_patches += [im]
                masked_patches += [ma]
    tampered.append(tampered_patches)
    masks.append(masked_patches)
  return tampered , masks

"""uneven shapes"""

img=cv2.imread(gt_train['0'].iloc[2650])
img1=cv2.imread(train_tp['0'].iloc[2650])

cv2_imshow(img)
print(img.shape)
cv2_imshow(img1)
print(img1.shape)

# cv2_imshow(tampered_patches[61])
# cv2_imshow(masked_patches[61])

"""Tampered patch list"""

# tampered_patch_list , mask_patch_list =patch_cal(train_data_frame)

# tampered_patch_test , mask_patch_test =patch_cal(test_data_frame)

"""pick random 10"""

import random
def chosen_ones(l1): #m1):
    l3=[]
    # m3=[]
    for i in tqdm(range(len(l1))):  #,m1)):
        k=len(l1[i])
        l2=[]
        # m2=[]
        for j in range(10):
            num=random.randrange(0, k, 4)
            l2.append(l1[i][num])
            # m2.append(m1[i][num])

        l3.append(l2)
        # m3.append(m2)
    return l3 #, m3

"""Authentic patch extractor"""

def authentic_patch(df):

  l1=[]
  stride =8
  window_shape = (128, 128, 3)
  for i in tqdm(range(len(df))):
    au=cv2.imread(df['0'].iloc[i])
    non_tampered_windows = view_as_windows(au, window_shape, step=stride)
    non_tampered_patches = []
    for m in range(non_tampered_windows.shape[0]):
        for n in range(non_tampered_windows.shape[1]):
            non_tampered_patches += [non_tampered_windows[m][n][0]]
    l1.append(non_tampered_patches)
  return l1







"""## **load patches - files details**

tampered - patches_train/test.sav
tampered_mask- patches_mask_train.sav
authentic- au_patches_train/test.sav

original data in files test/train_au and test/train_tp
"""

tp_train=pickle.load(open('patches_train.sav','rb'))
tp_test=pickle.load(open('patches_test.sav','rb'))

tp_mask_train=pickle.load(open('patches_mask_train.sav','rb'))
tp_mask_test=pickle.load(open('patches_mask_test.sav','rb'))

au_train=pickle.load(open('au_patches_train.sav','rb'))
au_test=pickle.load(open('au_patches_test.sav','rb'))

cv2_imshow(np.hstack([tp_train[45][2],tp_train[45][5],tp_train[45][9]]))

cv2_imshow(np.hstack([tp_mask_train[45][2],tp_mask_train[45][5],tp_mask_train[45][9]]))

cv2_imshow(np.hstack([au_train[45][2],au_train[45][5],au_train[45][9]]))





"""patches creation for loading into cnn - WITHOUT GROUND TRUTH METHOD"""

# for i in tqdm(range(len(au_train))):
#   image = au_train[i]
#   inds = np.random.choice(10, 7, replace=False)
#   for ind in enumerate(inds):
#     io.imsave('/content/drive/My Drive/SML _ PROJECT/Authentic_patch/' + str(ind[0]) + '_' + str(i) + '_' + '1_.png', np.asarray(image[ind[1]]) )

# for i in tqdm(range(len(tp_train))):
#   image = tp_train[i]
#   inds = np.random.choice(10, 7, replace=False)
#   for ind in enumerate(inds):
#     io.imsave('/content/drive/My Drive/SML _ PROJECT/tampered_patch/' + str(ind[0]) + '_' + str(i) + '_' + '0_.png', np.asarray(image[ind[1]]) )

# for i in tqdm(range(len(tp_test))):
#   image = tp_test[i]
#   inds = np.random.choice(10, 7, replace=False)
#   for ind in enumerate(inds):
#     io.imsave('/content/drive/My Drive/SML _ PROJECT/tampered_test_patch/' + str(ind[0]) + '_' + str(i) + '_' + '0.png', np.asarray(image[ind[1]]) )

# for i in tqdm(range(len(au_test))):
#   image = au_test[i]
#   inds = np.random.choice(10, 7, replace=False)
#   for ind in enumerate(inds):
#     io.imsave('/content/drive/My Drive/SML _ PROJECT/Authentic_test_patch/' + str(ind[0]) + '_' + str(i) + '_' + '0.png', np.asarray(image[ind[1]]) )

# def feature_patch(df):

#   l1=[]
#   stride =128
#   window_shape = (128, 128, 3)
#   for i in tqdm(range(len(df))):
#     au=cv2.imread(df['0'].iloc[i])
#     non_tampered_windows = view_as_windows(au, window_shape, step=stride)
#     non_tampered_patches = []
#     for m in range(non_tampered_windows.shape[0]):
#         for n in range(non_tampered_windows.shape[1]):
#             non_tampered_patches += [non_tampered_windows[m][n][0]]
#     l1.append(non_tampered_patches)
#   return l1

# au_f=feature_patch(train_au)

# for i in tqdm(range(len(au_f))):
#   image = au_f[i]
#   # inds = np.random.choice(10, 7, replace=False)
#   for ind in range(len(image)):
#     io.imsave('/content/drive/My Drive/SML _ PROJECT/features/au/' + str(i) + '_' + str(ind) + '_' + '1_.png', np.asarray(image[ind]) )

# tp_f=feature_patch(train_tp)

# for i in tqdm(range(len(tp_f))):
#   image = tp_f[i]
#   # inds = np.random.choice(10, 7, replace=False)
#   for ind in range(len(image)):
#     io.imsave('/content/drive/My Drive/SML _ PROJECT/features/tp/' + str(i) + '_' + str(ind) + '_' + '0_.png', np.asarray(image[ind]) )







"""# Analysis on Filters"""

img=cv2.imread(train_tp['0'].iloc[1890])
img_au=cv2.imread(gt_train['0'].iloc[1890]) #aajaaaa

img= cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# img_au= cv2.cvtColor(img_au, cv2.COLOR_BGR2GRAY)

cv2_imshow(img)
cv2_imshow(img_au)#theek????

kernel_horizontal = np.array([np.array([1, 1,1]),np.array([0, 0, 0]), np.array([-1, -1,-1])]) 
print(kernel_horizontal, 'is a kernel for detecting horizontal edges')

from scipy import ndimage
cimg=ndimage.convolve(img, kernel_horizontal, mode='constant', cval=0.0)

cv2_imshow(cimg)

#https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.ndimage.filters.convolve.html

yeh tere kernels 10 jo ki usme theee

k1 =np.array([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, -1, 1, 0], [0, 0, 0, 0, 0],
                                      [0, 0, 0, 0, 0]])

k2=np.array([[0, 0, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, -1, 0, 0], [0, 0, 0, 0, 0],
                                      [0, 0, 0, 0, 0]])

k3=np.array([[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, -2, 1, 0], [0, 0, 0, 0, 0],
                                      [0, 0, 0, 0, 0]])

k4=np.array([[0, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, -2, 0, 0], [0, 0, 0, 1, 0],
                                      [0, 0, 0, 0, 0]])

k5=np.array([[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 1, -3, 1, 0], [0, 0, 0, 0, 0],
                                      [0, 0, 0, 0, 0]])

k6=np.array([[0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, -3, 0, 0], [0, 1, 0, 0, 0],
                                      [0, 0, 0, 0, 0]])

k7=np.array([[0, 0, 0, 0, 0], [0, -1, 2, -1, 0], [0, 2, -4, 2, 0], [0, -1, 2, -1, 0],
                                       [0, 0, 0, 0, 0]])

k8=np.array([[0, 0, 0, 0, 0], [0, -1, 2, -1, 0], [0, 2, -4, 2, 0], [0, 0, 0, 0, 0],
                                        [0, 0, 0, 0, 0]])

k9=np.array([[-1, 2, -2, 2, -1], [2, -6, 8, -6, 2], [-2, 8, -12, 8, -2],
                                        [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]])

k10=np.array([[-1, 2, -2, 2, -1], [2, -6, 8, -6, 2], [-2, 8, -12, 8, -2],
                                       [2, -6, 8, -6, 2], [-1, 2, -2, 2, -1]])

cimg=ndimage.convolve(img ,k1, mode='constant', cval=0.0)   
cv2_imshow(cimg)

cimg=ndimage.convolve(img,k2, mode='constant', cval=0.0)
cv2_imshow(cimg)

cimg=ndimage.convolve(img,k3, mode='constant', cval=0.0)
cv2_imshow(cimg)

cimg=ndimage.convolve(img,k4, mode='constant', cval=0.0)
cv2_imshow(cimg)

cimg=ndimage.convolve(img,k5,  mode='constant', cval=0.0)
cv2_imshow(cimg)

cimg=ndimage.convolve(img,k6,  mode='constant', cval=0.0)
cv2_imshow(cimg)

cimg=ndimage.convolve(img,k7,  mode='constant', cval=0.0)
cv2_imshow(cimg)

cimg=ndimage.convolve(img,k8, mode='constant', cval=0.0)
cv2_imshow(cimg)

cimg=ndimage.convolve(img,k9, mode='constant', cval=0.0)
cv2_imshow(np.hstack([img,cimg]))

cimg=ndimage.convolve(img,k10, mode='constant', cval=0.0)
cv2_imshow(np.hstack([cimg,img]))

